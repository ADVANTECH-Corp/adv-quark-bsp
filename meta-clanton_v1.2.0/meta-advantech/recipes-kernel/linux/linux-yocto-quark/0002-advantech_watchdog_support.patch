diff -ruN '--exclude=.svn' linux-3.24.28.orig/drivers/platform/x86/intel-quark/intel_quark_platform_cross_hill.c linux-3.14.28/drivers/platform/x86/intel-quark/intel_quark_platform_cross_hill.c
--- linux-3.24.28.orig/drivers/platform/x86/intel-quark/intel_quark_platform_cross_hill.c	2015-11-12 01:16:39.433755208 +0800
+++ linux-3.14.28/drivers/platform/x86/intel-quark/intel_quark_platform_cross_hill.c	2015-11-17 13:29:25.953350813 +0800
@@ -16,10 +16,17 @@
 
 #include <linux/errno.h>
 #include <linux/gpio.h>
+#ifdef CONFIG_ADVANTECH_RISC_WDT
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#endif
 #include <linux/io.h>
 #include <linux/ioport.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#ifdef CONFIG_ADVANTECH_RISC_WDT
+#include <linux/mfd/intel_qrk_gip_pdata.h>
+#endif
 #include <linux/printk.h>
 #include <linux/spi/pxa2xx_spi.h>
 #include <linux/spi/spi.h>
@@ -78,6 +85,18 @@
 	QRK_SPI_BPEAK_ID_NONE
 };
 
+#ifdef CONFIG_ADVANTECH_RISC_WDT
+#define WDT_ADDR				0x29
+static struct i2c_board_info probed_i2c_wdt;
+static const unsigned short wdt_i2c_addr[] = {
+	WDT_ADDR, I2C_CLIENT_END
+};
+static int i2c_probe(struct i2c_adapter *adap, unsigned short addr)
+{
+	return 1;
+}
+#endif
+
 /******************************************************************************
  *             Trust Platform Module
  ******************************************************************************/
@@ -461,7 +480,29 @@
 {
 	int ret;
 	sc_gpio_reg = 1;
+#ifdef CONFIG_ADVANTECH_RISC_WDT
+	static int spi_done, i2c_done;
+	struct i2c_adapter *i2c_adap = NULL;
+	struct i2c_client *client = NULL;
+
+	i2c_adap = i2c_get_adapter(0);
 
+	if (NULL == i2c_adap) {
+		pr_info("%s: i2c adapter not ready yet. Deferring..\n",
+		__func__);
+		return -EPROBE_DEFER;
+	}
+	strlcpy(probed_i2c_wdt.type, "adv-wdt-i2c", I2C_NAME_SIZE);
+	client = i2c_new_probed_device(i2c_adap, &probed_i2c_wdt,wdt_i2c_addr, i2c_probe);
+	pr_info("[adv-wdt-i2c] i2c_new_probed_device \n");             
+	if (client == NULL) {
+		pr_err("%s: Failed to probe RTC I2C device\n", __func__);
+		ret = -ENODEV;
+		goto end;
+	}
+end:
+	i2c_put_adapter(i2c_adap);
+#endif
 	if (nc_gpio_reg == 1 && sc_gpio_reg == 1) {
 		ret = intel_qrk_spi_devs_addon();
 		if (ret)
diff -ruN '--exclude=.svn' linux-3.24.28.orig/drivers/watchdog/ie6xx_wdt.c linux-3.14.28/drivers/watchdog/ie6xx_wdt.c
--- linux-3.24.28.orig/drivers/watchdog/ie6xx_wdt.c	2015-11-12 01:17:59.353753797 +0800
+++ linux-3.14.28/drivers/watchdog/ie6xx_wdt.c	2015-11-17 10:57:21.409511930 +0800
@@ -33,6 +33,10 @@
 #include <linux/uaccess.h>
 #include <linux/spinlock.h>
 
+#ifdef CONFIG_ARCH_ADVANTECH
+#include <linux/delay.h>
+#endif
+
 #define DRIVER_NAME "ie6xx_wdt"
 
 #define PV1	0x00
@@ -320,6 +324,10 @@
 {
 	/* Check boot parameters to verify that their initial values */
 	/* are in range. */
+#ifdef CONFIG_ARCH_ADVANTECH
+	msleep(1600);
+	pr_info("ie6xx_wdt_init\n");
+#endif
 	if ((timeout < MIN_TIME) ||
 	    (timeout > MAX_TIME)) {
 		pr_err("Watchdog timer: value of timeout %d (dec) "
diff -ruN '--exclude=.svn' linux-3.24.28.orig/drivers/watchdog/Kconfig linux-3.14.28/drivers/watchdog/Kconfig
--- linux-3.24.28.orig/drivers/watchdog/Kconfig	2015-11-12 01:17:58.533753811 +0800
+++ linux-3.14.28/drivers/watchdog/Kconfig	2015-11-17 10:51:55.381517687 +0800
@@ -28,6 +28,17 @@
 
 if WATCHDOG
 
+config ADVANTECH_RISC_WDT
+	tristate "ADVANTECH Watchdog"
+	depends on X86
+	help
+	  This is the driver for the hardware watchdog
+	  If you have one of these processors and wish to have
+	  watchdog support enabled, say Y, otherwise say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called adv_wdt.
+
 config WATCHDOG_CORE
 	bool "WatchDog Timer Driver Core"
 	---help---
diff -ruN '--exclude=.svn' linux-3.24.28.orig/drivers/watchdog/Makefile linux-3.14.28/drivers/watchdog/Makefile
--- linux-3.24.28.orig/drivers/watchdog/Makefile	2015-11-12 01:17:58.457753813 +0800
+++ linux-3.14.28/drivers/watchdog/Makefile	2015-11-17 10:55:15.909514146 +0800
@@ -4,6 +4,7 @@
 
 # The WatchDog Timer Driver Core.
 watchdog-objs	+= watchdog_core.o watchdog_dev.o
+obj-$(CONFIG_ADVANTECH_RISC_WDT)	+= watchdog_advantech.o
 obj-$(CONFIG_WATCHDOG_CORE)	+= watchdog.o
 
 # Only one watchdog can succeed. We probe the ISA/PCI/USB based
diff -ruN '--exclude=.svn' linux-3.24.28.orig/drivers/watchdog/watchdog_advantech.c linux-3.14.28/drivers/watchdog/watchdog_advantech.c
--- linux-3.24.28.orig/drivers/watchdog/watchdog_advantech.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-3.14.28/drivers/watchdog/watchdog_advantech.c	2015-11-17 11:16:12.921491950 +0800
@@ -0,0 +1,498 @@
+/*
+ * Advantech Watchdog driver
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/watchdog.h>
+#include <linux/clk.h>
+#include <linux/fs.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+
+#define ADV_WDT_WCR		0x00		/* Control Register */
+#define ADV_WDT_WCR_WT		(0xFF << 8)	/* -> Watchdog Timeout Field */
+#define ADV_WDT_WCR_WRE	(1 << 3)	/* -> WDOG Reset Enable */
+#define ADV_WDT_WCR_WDE	(1 << 2)	/* -> Watchdog Enable */
+#define ADV_WDT_WCR_WDZST	(1 << 0)	/* -> Watchdog timer Suspend */
+
+#define ADV_WDT_WSR		0x02		/* Service Register */
+#define ADV_WDT_SEQ1		0x5555		/* -> service sequence 1 */
+#define ADV_WDT_SEQ2		0xAAAA		/* -> service sequence 2 */
+
+#define ADV_WDT_WRSR		0x04		/* Reset Status Register */
+#define ADV_WDT_WRSR_TOUT	(1 << 1)	/* -> Reset due to Timeout */
+
+#define ADV_WDT_MAX_TIME	65536
+#define ADV_WDT_DEFAULT_TIME	60		/* in seconds */
+
+#define WDOG_SEC_TO_COUNT(s)	(s * 10) //Time unite: 100ms -> 1s
+
+#define ADV_WDT_STATUS_OPEN	0
+#define ADV_WDT_STATUS_STARTED	1
+#define ADV_WDT_EXPECT_CLOSE	2
+
+#define DRIVER_NAME "adv-wdt-i2c"
+
+#define REG_WDT_WATCHDOG_TIME_OUT	0x15
+#define REG_WDT_POWER_OFF_TIME 		0x16
+#define REG_WDT_INT_PRE_TIME 			0x17
+#define REG_WDT_REMAIN_TIME_OUT		0x25
+#define REG_WDT_REMAIN_PRE_TIME 	0x26
+#define REG_WDT_VERSION 					0x27
+#define REG_WDT_POWER_BTN_MODE 		0x28
+
+#define GPIO_WDT_ENABLE 14
+#define GPIO_WDOG   12
+
+int gpio_wdt_en;
+int gpio_wdt_ping;
+
+static struct gpio reserved_gpios[] = {
+        {
+                GPIO_WDT_ENABLE,
+                GPIOF_OUT_INIT_LOW,
+                "wdt_enable",
+        },
+        {
+                GPIO_WDOG,
+                GPIOF_OUT_INIT_LOW,
+                "wdt_ping",
+        },
+};
+
+//EXPORT_SYMBOL(gpio_wdt_en);
+//EXPORT_SYMBOL(gpio_wdt_ping);
+
+struct i2c_client *adv_client;
+
+static struct {
+	struct clk *clk;
+	unsigned timeout;
+	unsigned remain_time;
+	unsigned long status;
+	int wdt_ping_status;
+	char version[2];
+} adv_wdt;
+
+static struct miscdevice adv_wdt_miscdev;
+
+static bool nowayout = 0;
+
+module_param(nowayout, bool, 0);
+
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default="
+				__MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+
+static unsigned timeout = ADV_WDT_DEFAULT_TIME;
+
+module_param(timeout, uint, 0);
+
+MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds (default="
+				__MODULE_STRING(ADV_WDT_DEFAULT_TIME) ")");
+
+struct watchdog_info adv_wdt_info = {
+	.identity = "Advantech watchdog",
+	.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT | WDIOF_MAGICCLOSE,
+	.firmware_version = 0,
+};
+
+static int adv_wdt_i2c_write_reg(struct i2c_client *client, u8 reg, void *buf, size_t len)
+{
+	u8 val[1 + len];
+	struct i2c_msg msg[1] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = sizeof(val),
+			.buf = val,
+		}
+	};
+
+	val[0] = reg;
+	memcpy(&val[1], buf, len);
+
+	if (i2c_transfer(client->adapter, msg, 1) != 1) {
+		dev_err(&client->dev, "adv_wdt_i2c_write: i2c transfer failed\n");
+		return -EIO;
+	}
+	
+	msleep(100);
+	return 0;
+}
+
+static int adv_wdt_i2c_read_reg(struct i2c_client *client, u8 reg, void *buf, size_t len)
+{
+	struct i2c_msg msg[2] = {
+		{
+			.addr	= client->addr,
+			.flags	= 0,
+			.len	= 1,
+			.buf	= &reg,
+		},
+		{
+			.addr	= client->addr,
+			.flags	= I2C_M_RD,
+			.len	= len,
+			.buf	= buf,
+		}
+	};
+
+	if (i2c_transfer(client->adapter, msg, 2) != 2) {
+		dev_err(&client->dev, "adv_wdt_i2c_read: i2c transfer failed\n");
+		return -EIO;
+	}
+
+	msleep(100);
+	return 0;
+}
+
+int adv_wdt_i2c_set_timeout(struct i2c_client *client, int val)
+{
+	int ret = 0;
+
+	val = WDOG_SEC_TO_COUNT(val);
+	ret = adv_wdt_i2c_write_reg(client, REG_WDT_WATCHDOG_TIME_OUT, &val, sizeof(val));
+	if (ret)
+		return -EIO;
+	return 0;
+}
+
+int adv_wdt_i2c_read_timeout(struct i2c_client *client, int *val)
+{
+	int ret = 0;
+	
+	ret = adv_wdt_i2c_read_reg(client, REG_WDT_WATCHDOG_TIME_OUT, val, sizeof(val));
+	if (ret)
+		return -EIO;
+	return 0;
+}
+
+int adv_wdt_i2c_read_remain_time(struct i2c_client *client, int *val)
+{
+	int ret = 0;
+	
+	ret = adv_wdt_i2c_read_reg(client, REG_WDT_REMAIN_TIME_OUT, val, sizeof(val));
+	if (ret)
+		return -EIO;
+	return 0;
+}
+
+int adv_wdt_i2c_read_version(struct i2c_client *client, int *val)
+{
+	int ret = 0;
+	
+	ret = adv_wdt_i2c_read_reg(client, REG_WDT_VERSION, val, sizeof(val));
+	if (ret)
+		return -EIO;
+	return 0;
+}
+
+static inline void adv_wdt_ping(void)
+{
+	msleep(800);
+	adv_wdt.wdt_ping_status= !adv_wdt.wdt_ping_status;
+	gpio_set_value(gpio_wdt_ping, adv_wdt.wdt_ping_status);
+	msleep(100);
+	//printk("adv_wdt_ping:%x\n", adv_wdt.wdt_ping_status);
+	//printk("wdt_en_ping:%x\n", gpio_get_value(gpio_wdt_en));
+}
+
+static void adv_wdt_start(void)
+{
+	if (!test_and_set_bit(ADV_WDT_STATUS_STARTED, &adv_wdt.status)) 
+	{
+		/* at our first start we enable clock and do initialisations */
+		gpio_set_value(gpio_wdt_en, 1);
+	} 
+
+	/* Watchdog is enabled - time to reload the timeout value */
+	adv_wdt_ping();
+}
+
+static void adv_wdt_stop(void)
+{
+	adv_wdt_ping();
+
+	/* we don't need a clk_disable, it cannot be disabled once started.
+	 * We use a timer to ping the watchdog while /dev/watchdog is closed */
+	gpio_set_value(gpio_wdt_en, 0);
+}
+
+static int adv_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(ADV_WDT_STATUS_OPEN, &adv_wdt.status))
+		return -EBUSY;
+	adv_wdt_start();
+	return nonseekable_open(inode, file);
+}
+
+static int adv_wdt_close(struct inode *inode, struct file *file)
+{
+	if (test_bit(ADV_WDT_EXPECT_CLOSE, &adv_wdt.status) && !nowayout)
+		adv_wdt_stop();
+	else {
+		dev_crit(adv_wdt_miscdev.parent,
+			"Unexpected close: Expect reboot!\n");
+		adv_wdt_ping();
+	}
+
+	clear_bit(ADV_WDT_EXPECT_CLOSE, &adv_wdt.status);
+	clear_bit(ADV_WDT_STATUS_OPEN, &adv_wdt.status);
+	clear_bit(ADV_WDT_STATUS_STARTED, &adv_wdt.status);
+	return 0;
+}
+
+static long adv_wdt_ioctl(struct file *file, unsigned int cmd,
+							unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+	int new_value = 0;
+//	u16 val;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		adv_wdt_ping();
+		return copy_to_user(argp, &adv_wdt_info,
+			sizeof(struct watchdog_info)) ? -EFAULT : 0;
+
+	case WDIOC_GETSTATUS:
+		return put_user(adv_wdt.status, p);
+/*
+	case WDIOC_GETBOOTSTATUS:
+		val = __raw_readw(adv_wdt.base + ADV_WDT_WRSR);
+		new_value = val & ADV_WDT_WRSR_TOUT ? WDIOF_CARDRESET : 0;
+		return put_user(new_value, p);
+*/
+	case WDIOC_KEEPALIVE:
+		adv_wdt_ping();
+		return 0;
+
+	case WDIOC_SETTIMEOUT:
+		if (get_user(new_value, p))
+			return -EFAULT;
+		if ((new_value < 1) || (new_value > ADV_WDT_MAX_TIME))
+		{
+			return -EINVAL;
+		}
+		adv_wdt.timeout = new_value;
+		adv_wdt_i2c_set_timeout(adv_client, adv_wdt.timeout);
+		adv_wdt_ping();
+	
+		/* Fallthrough to return current value */
+	case WDIOC_GETTIMEOUT:
+		adv_wdt_i2c_read_timeout(adv_client, &adv_wdt.timeout);
+		//printk("WDIOC_GETTIMEOUT:%x\n", adv_wdt.timeout);
+		return put_user(adv_wdt.timeout & 0xFFFF, p);
+
+	case WDIOC_GETTIMELEFT:
+		adv_wdt_i2c_read_remain_time(adv_client, &adv_wdt.remain_time);
+		//printk("WDIOC_GETTIMELEFT:%x\n", adv_wdt.remain_time);
+		return put_user(adv_wdt.remain_time & 0xFFFF, p);
+	
+	default:
+		return -ENOTTY;
+	}
+}
+
+static ssize_t adv_wdt_write(struct file *file, const char __user *data,
+						size_t len, loff_t *ppos)
+{
+	size_t i;
+	char c;
+
+	if (len == 0)	/* Can we see this even ? */
+		return 0;
+
+	clear_bit(ADV_WDT_EXPECT_CLOSE, &adv_wdt.status);
+	/* scan to see whether or not we got the magic character */
+	for (i = 0; i != len; i++) {
+		if (get_user(c, data + i))
+			return -EFAULT;
+		if (c == 'V')
+			set_bit(ADV_WDT_EXPECT_CLOSE, &adv_wdt.status);
+	}
+
+	adv_wdt_ping();
+	
+	return len;
+}
+
+static const struct file_operations adv_wdt_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.unlocked_ioctl = adv_wdt_ioctl,
+	.open = adv_wdt_open,
+	.release = adv_wdt_close,
+	.write = adv_wdt_write,
+};
+
+static struct miscdevice adv_wdt_miscdev = {
+	.minor = WATCHDOG_MINOR,
+	.name = "watchdog",
+	.fops = &adv_wdt_fops,
+};
+
+static int gpio_setting(void)
+{
+	int ret;
+	
+	ret = gpio_request_array(reserved_gpios,ARRAY_SIZE(reserved_gpios));
+	if (ret) {
+		pr_err("%s: Failed to allocate audio control GPIO pins\n",
+		       __func__);
+		return ret;
+	}
+	return 0;
+}
+
+static int adv_wdt_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int ret;
+	int tmp_version;
+	
+	gpio_wdt_en=GPIO_WDT_ENABLE;
+	gpio_wdt_ping=GPIO_WDOG;
+  	pr_info("adv_wdt_i2c_probe Enable[%d]  WDOG[%d]\n",gpio_wdt_en,gpio_wdt_ping);
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+	{
+		return -ENODEV;
+	}	
+
+	i2c_set_clientdata(client, &adv_wdt);
+
+	ret = adv_wdt_i2c_read_version(client, &tmp_version);
+	if(ret!=0){ 
+	 printk("RISC wdt i2c fail\n");
+	 goto fail;
+	}
+	else{ 
+	 printk("RISC wdt i2c pass\n");
+	}
+
+	adv_client = client;
+	//Setting GPIO
+	ret = gpio_setting();
+	if (ret < 0) {
+		dev_err(&client->dev, "request gpio failed: %d\n", ret);
+		return ret;
+	}
+	gpio_direction_output(gpio_wdt_en, 0);
+	msleep(10);
+	adv_wdt.wdt_ping_status=0;
+	gpio_direction_output(gpio_wdt_ping, 1);
+	msleep(10);
+	gpio_direction_output(gpio_wdt_ping, 0);
+
+	adv_wdt.timeout = clamp_t(unsigned, timeout, 1, ADV_WDT_MAX_TIME);
+	if (adv_wdt.timeout != timeout)
+		dev_warn(&client->dev, "Initial timeout out of range! "
+			"Clamped from %u to %u\n", timeout, adv_wdt.timeout);
+
+	adv_wdt_miscdev.parent = &client->dev;
+	ret = misc_register(&adv_wdt_miscdev);
+	if (ret)
+	{
+		pr_err("cannot register miscdev on minor=%d (err=%d)\n",
+	     WATCHDOG_MINOR, ret);
+		goto fail;
+	}
+	
+	//ret = adv_wdt_i2c_read_version(client, &tmp_version);
+	
+	if (ret == 0 )
+	{
+	adv_wdt.version[0]= (tmp_version & 0xFF00) >> 8;
+	adv_wdt.version[1]= tmp_version & 0xFF;
+	adv_wdt_info.firmware_version = (int)(adv_wdt.version[1] - '0') * 10 + (int)(adv_wdt.version[0] - '0');
+	}
+	dev_info(&client->dev,
+						"Advantech Watchdog Timer enabled. timeout=%ds (nowayout=%d), Ver.%d\n",
+						adv_wdt.timeout, nowayout, adv_wdt_info.firmware_version);
+	return 0;
+
+fail:
+	adv_wdt_miscdev.parent = NULL;
+	return ret;
+}
+
+static int __exit adv_wdt_i2c_remove(struct i2c_client *client)
+{
+	misc_deregister(&adv_wdt_miscdev);
+
+	if (test_bit(ADV_WDT_STATUS_STARTED, &adv_wdt.status))
+	{	
+		gpio_set_value(gpio_wdt_en, 0);
+		dev_crit(adv_wdt_miscdev.parent, "Device removed: Expect reboot!\n");
+	}
+	adv_wdt_miscdev.parent = NULL;
+	return 0;
+}
+
+static void adv_wdt_i2c_shutdown(struct i2c_client *client)
+{
+	if (test_bit(ADV_WDT_STATUS_STARTED, &adv_wdt.status)) {
+		/* we are running, we need to delete the timer but will give
+		 * max timeout before reboot will take place */
+		gpio_set_value(gpio_wdt_en, 0);		
+		adv_wdt_i2c_set_timeout(client, ADV_WDT_MAX_TIME);
+		adv_wdt_ping();
+
+		dev_crit(adv_wdt_miscdev.parent,
+			"Device shutdown: Expect reboot!\n");
+	}
+}
+
+static const struct i2c_device_id adv_wdt_i2c_id[] = {
+	{DRIVER_NAME, 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, adv_wdt_i2c_id);
+
+static const struct of_device_id adv_wdt_i2c_dt_ids[] = {
+	{ .compatible = "fsl,adv-wdt-i2c", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, adv_wdt_i2c_dt_ids);
+
+static struct i2c_driver adv_wdt_i2c_driver = {
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   .of_match_table = adv_wdt_i2c_dt_ids,
+		   },
+	.probe = adv_wdt_i2c_probe,
+	.remove = adv_wdt_i2c_remove,
+	.shutdown	= adv_wdt_i2c_shutdown,
+	.id_table = adv_wdt_i2c_id,
+};
+
+static int __init adv_wdt_i2c_init(void)
+{
+	return i2c_add_driver(&adv_wdt_i2c_driver);
+}
+
+static void __exit adv_wdt_i2c_exit(void)
+{
+	i2c_del_driver(&adv_wdt_i2c_driver);
+}
+
+module_init(adv_wdt_i2c_init);
+module_exit(adv_wdt_i2c_exit);
+
+MODULE_DESCRIPTION("Advantech Watchdog I2C Driver");
+MODULE_LICENSE("GPL");
