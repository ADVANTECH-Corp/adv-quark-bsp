From cd18dda11480b4322fb1d88d2f15fb660168281a Mon Sep 17 00:00:00 2001
From: Kai Ji <kai.ji@intel.com>
Date: Thu, 24 Sep 2015 14:39:54 +0100
Subject: [PATCH 365/366] Release: Remove internal ESRAM & IMR test drivers

These are test drivers and not required by the release

Please note above are functional drivers are designed
only for internal testing & validation purposes.

Signed-off-by: Kai Ji <kai.ji@intel.com>
Change-Id: I5f869a3d1ac8b34079655eee506c670dcbf33b72
Reviewed-on: https://git-gar-1.devtools.intel.com/gerrit/6759
Reviewed-by: Murphy, Dermot B <dermot.b.murphy@intel.com>
Reviewed-by: O Connell, Cliona <cliona.o.connell@intel.com>
Reviewed-by: Fung, Joshua <joshua.fung@intel.com>
---
 arch/x86/platform/intel-quark/Makefile             |   2 -
 .../platform/intel-quark/intel_qrk_esram_test.c    | 583 ---------------------
 .../platform/intel-quark/intel_qrk_esram_test.h    |  36 --
 arch/x86/platform/intel-quark/intel_qrk_imr_test.c | 351 -------------
 4 files changed, 972 deletions(-)
 delete mode 100644 arch/x86/platform/intel-quark/intel_qrk_esram_test.c
 delete mode 100644 arch/x86/platform/intel-quark/intel_qrk_esram_test.h
 delete mode 100644 arch/x86/platform/intel-quark/intel_qrk_imr_test.c

diff --git a/arch/x86/platform/intel-quark/Makefile b/arch/x86/platform/intel-quark/Makefile
index 53f0391..3bea62b 100644
--- a/arch/x86/platform/intel-quark/Makefile
+++ b/arch/x86/platform/intel-quark/Makefile
@@ -1,4 +1,2 @@
 obj-$(CONFIG_INTEL_IMR) += imr.o
-obj-$(CONFIG_INTEL_IMR) += intel_qrk_imr_test.o
 obj-$(CONFIG_INTEL_QRK_ESRAM)	+= intel_qrk_esram.o
-obj-$(CONFIG_INTEL_QRK_ESRAM)	+= intel_qrk_esram_test.o
diff --git a/arch/x86/platform/intel-quark/intel_qrk_esram_test.c b/arch/x86/platform/intel-quark/intel_qrk_esram_test.c
deleted file mode 100644
index 9cad819..0000000
--- a/arch/x86/platform/intel-quark/intel_qrk_esram_test.c
+++ /dev/null
@@ -1,583 +0,0 @@
-/*
- * Copyright(c) 2013,2014 Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-/**
- * intel_qrk_esram_test.c
- *
- * Simple test module to provide test cases for ITS integration
- *
- */
-#include <linux/cdev.h>
-#include <linux/crc32.h>
-#include <linux/crc32c.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/kallsyms.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/slab.h>
-
-#include "intel_qrk_esram.h"
-#include "intel_qrk_esram_test.h"
-
-#define DRIVER_NAME			"intel_qrk_esram_test"
-
-/**
- * struct intel_qrk_esram_dev
- *
- * Structre to represent module state/data/etc
- */
-struct intel_qrk_esram_test_dev{
-	unsigned int opened;
-	struct platform_device *pldev;	/* Platform device */
-	struct cdev cdev;
-	struct mutex open_lock;
-	char * pdata;
-	u32 size;
-};
-
-static struct intel_qrk_esram_test_dev esram_test_dev;
-static struct class *esram_test_class;
-static DEFINE_MUTEX(esram_test_mutex);
-static int esram_test_major;
-static char * name = "testmap";
-
-/******************************************************************************
- *                                eSRAM BIST
- ******************************************************************************/
-
-static int crc_cache = 0;
-
-unsigned long long tsc_delta(unsigned long long first, unsigned long long end)
-{
-	if (first < end)
-		return end - first;
-	else
-		return (ULLONG_MAX - first) + end;	
-}
-
-
-/**
- * intel_qrk_crctest
- *
- * Do a CRC32 of the specified region. Return the time taken in jiffies
- */
-static unsigned long long intel_qrk_crctest(char * pdata, u32 crcsize)
-{
-	unsigned long long j1 = 0, j2 = 0;
-	
-	rdtscll(j1);
-
-	/* Flush LMT cache to introduce cache miss to our test */
-	__asm__ __volatile__("wbinvd\n");
-	crc32(0, pdata, crcsize);
-
-	rdtscll(j2);
-
-	return tsc_delta(j1, j2);
-}
-
-#ifdef __DEBUG__
-#define bist_err(x){\
-	pr_err("eSRAM bist err line %d errno %d\n", (__LINE__-2), x);\
-	return x;\
-}
-#else
-#define bist_err(x){\
-	return x;\
-}
-#endif
-/**
- * intel_qrk_esram_perpage_overlay
- *
- * Maps to integration test spec ID CLN.F.SW.APP.eSRAM.0
- */
-int intel_qrk_esram_test_perpage_overlay(void)
-{
-
-	int ret = 0;
-	u32 idx = 0, size = INTEL_QRK_ESRAM_PAGE_SIZE;
-
-	/* Set a known state */
-	for(idx = 0; idx < size; idx += sizeof(u32)){
-		*((u32*)&esram_test_dev.pdata[idx]) = idx;
-	}
-
-
-	/* Basic test of full range of memory */
-	ret = intel_qrk_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-	for(idx = 0; idx < size; idx += sizeof(u32)){
-		if(*((u32*)&esram_test_dev.pdata[idx]) != idx){
-			pr_err("Entry %d is 0x%08x require 0x%08x",
-				idx, esram_test_dev.pdata[idx], idx);
-			bist_err(-EIO);
-		}
-	}
-
-#if 0
-	ret = intel_qrk_esram_unmap_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-#endif
-	return 0;
-}
-
-/**
- * intel_qrk_esram_test_pageref_count
- *
- * Ensure page reference couting works as expected
- */
-int intel_qrk_esram_test_pagref_count(void)
-{
-	u32 size = INTEL_QRK_ESRAM_PAGE_SIZE;
-	int ret = 0;
-
-	return 0;
-	/* Map a page */
-	ret = intel_qrk_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-
-	/* Map a second time - and verify mapping fails */
-	ret = intel_qrk_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret == 0){
-		bist_err(-EFAULT);
-	}
-
-#if 0
-	/* Unmap - OK */
-	ret = intel_qrk_esram_unmap_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-
-	/* Verify second unmap operation fails */
-	ret = intel_qrk_esram_unmap_range(esram_test_dev.pdata, size, name);
-	if(ret == 0){
-		bist_err(-EFAULT);
-	}
-#endif	
-	return 0;
-}
-
-/**
- * intel_qrk_esram_test_contig_perfmetric
- *
- * Do a CRC16 for a contigous area of memory
- * Map contigous area and get a CRC16
- *
- * Ensure overlayed data takes less time than regular unoverlayed DRAM
- */
-int intel_qrk_esram_test_contig_perfmetric(void)
-{
-	u32 crcsize = 0x60000;
-	unsigned long long crc32_fullmap = 0, crc32_fullunmap = 0;
-	int ret = 0;
-
-	/* Get raw data metric */
-	crc_cache = 1;
-	crc32_fullunmap = intel_qrk_crctest(esram_test_dev.pdata, crcsize);
-
-	/* Map test data */
-	ret = intel_qrk_esram_map_range(esram_test_dev.pdata, crcsize, name);
-	if(ret){
-		bist_err(ret);
-	}
-	
-	/* Get metric */
-	crc_cache = 1;
-	crc32_fullmap = intel_qrk_crctest(esram_test_dev.pdata, crcsize);
-#if 0
-	/* Tidy up */
-	ret = intel_qrk_esram_unmap_range(esram_test_dev.pdata, crcsize, name);
-	if(ret){
-		bist_err(ret);
-	}
-	ret = intel_qrk_esram_unmap_range(((void*)crc32_table),
-					  sizeof(crc32_table), name);
-	if(ret){
-		bist_err(ret);
-	}
-	ret = intel_qrk_esram_unmap_symbol(crc32);
-	if(ret){
-		bist_err(ret);
-	}
-#endif
-	pr_info("%s did crctest - mapped - in %llu ticks\n", __func__, crc32_fullmap);
-	pr_info("%s mapped count %llu unmapped %llu\n",
-		__func__, crc32_fullmap, crc32_fullunmap);
-	return crc32_fullmap < crc32_fullunmap;
-}
-
-/**
- * intel_qrk_esram_test_kernel_codemap
- *
- * Maps some kernel code - a data section and then calls the code contained
- * therein. Proves out the running overlayed eSRAM works
- */
-int intel_qrk_esram_test_kernel_codemap(void)
-{
-#if 0
-	int ret = intel_qrk_esram_map_symbol(msleep);
-	if(ret){
-		printk(KERN_ERR "%s map symbol msleep fail\n", __FUNCTION__);
-		bist_err(ret);
-	}
-	
-	/* run the mapped code */
-	msleep(1);
-
-	/* unmap */	
-	ret = intel_qrk_esram_unmap_symbol(msleep);
-	if(ret){
-		printk(KERN_ERR "%s unmap symbol msleep fail\n", __FUNCTION__);
-		bist_err(ret);
-	}
-#endif
-	return 0;
-}
-
-/**
- * intel_qrk_esram_test_kernel_datamap
- *
- * Tests mapping/unmapping of a kernel data structure
- */
-int intel_qrk_esram_test_kernel_datamap(void)
-{
-#if 0
-	unsigned long jtag = 0;
-	unsigned long ctrl = 0;
-
-	/* Map the interrupt descriptor table */
-	int ret = intel_qrk_esram_map_range(idt_table, INTEL_QRK_ESRAM_PAGE_SIZE, name);
-	if(ret){
-		bist_err(ret);
-	}
-	
-	jtag = jiffies;
-	/* Wait for jiffies to tick or timeout to occur (failure) */
-	while(jtag == jiffies){
-		ctrl++;
-	}
-
-	/* unmap */	
-	ret = intel_qrk_esram_unmap_range(idt_table, INTEL_QRK_ESRAM_PAGE_SIZE, name);
-	if(ret){
-		bist_err(ret);
-	}
-#endif
-	return 0;
-}
-
-/**
- * intel_qrk_esram_test_sub_unsub
- *
- * Subscribe and unsubscribe 100% of available eSRAM
- */
-int intel_qrk_esram_test_sub_unsub(void)
-{
-	int ret = 0;
-	u32 idx = 0, size = INTEL_QRK_ESRAM_PAGE_SIZE * INTEL_QRK_ESRAM_PAGE_COUNT;
-
-	/* Set a known state */
-	for(idx = 0; idx < size; idx += sizeof(u32)){
-		*((u32*)&esram_test_dev.pdata[idx]) = idx;
-	}
-
-	/* Basic test of full range of memory */
-	ret = intel_qrk_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-	for(idx = 0; idx < size; idx += sizeof(u32)){
-		if(*((u32*)&esram_test_dev.pdata[idx]) != idx){
-			pr_err("Entry %d is 0x%08x require 0x%08x",
-				idx, esram_test_dev.pdata[idx], idx);
-			bist_err(-EIO);
-		}
-	}
-#if 0
-	ret = intel_qrk_esram_unmap_range(esram_test_dev.pdata, size, name);
-	if(ret){
-		bist_err(ret);
-	}
-#endif
-	return 0;
-}
-
-/**
- * intel_qrk_esram_test_over_sub
- *
- * Test oversubscription of eSRAM
- */
-int intel_qrk_esram_test_over_sub(void)
-{
-	int ret = 0;
-	u32 size = INTEL_QRK_ESRAM_PAGE_SIZE * (INTEL_QRK_ESRAM_PAGE_COUNT + 1);
-
-	/* Over subscribe should fail */
-	ret = intel_qrk_esram_map_range(esram_test_dev.pdata, size, name);
-	if(ret == 0){
-		//intel_qrk_esram_unmap_range(esram_test_dev.pdata, size, name);
-		bist_err(-EFAULT);
-	}
-	return 0;
-}
-
-/*
- * File ops
- */
-static long esram_test_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
-{
-	int ret = -EINVAL;
-
-	cmd -= QRK_ESRAM_IOCTL_BASE;
-	switch (cmd) {
-		case QRK_F_SW_APP_ESRAM_0:
-			/* Per page overlay */
-			ret = intel_qrk_esram_test_perpage_overlay();
-			break;
-
-		case QRK_F_SW_APP_ESRAM_1:
-			/* Verify page reference counting */
-			ret = intel_qrk_esram_test_pagref_count();
-			break;
-
-		case QRK_F_SW_APP_ESRAM_2:
-			/* Performance metric or overlay contig RAM */
-			ret = intel_qrk_esram_test_contig_perfmetric();
-			if (ret == 1)
-				ret = 0;
-			break;
-
-		case QRK_F_SW_APP_ESRAM_3:
-			/* Verify mapping of kernel code section */
-			/* Covered by test #2 */
-			ret = 0; //intel_qrk_esram_test_kernel_codemap();
-			break;
-
-		case QRK_F_SW_APP_ESRAM_4:
-			/* Verify mapping of kernel data section (IDT) */
-			/* Covered by test #2 */
-			ret = 0; //intel_qrk_esram_test_kernel_datamap();
-			break;
-
-		case QRK_F_SW_APP_ESRAM_5:
-			/* Complete subscribe/unsubscribe eSRAM */
-			ret = intel_qrk_esram_test_sub_unsub();
-			break;
-
-		case QRK_F_SW_APP_ESRAM_6:
-			/* Over subscribe eSRAM */
-			ret = intel_qrk_esram_test_over_sub();
-			break;
-
-		default:
-			break;
-	}
-
-	return ret;
-}
-
-static int esram_test_open(struct inode *inode, struct file *file)
-{
-	mutex_lock(&esram_test_mutex);
-	nonseekable_open(inode, file);
-
-	if (mutex_lock_interruptible(&esram_test_dev.open_lock)) {
-		mutex_unlock(&esram_test_mutex);
-		return -ERESTARTSYS;
-	}
-
-	if (esram_test_dev.opened) {
-		mutex_unlock(&esram_test_dev.open_lock);
-		mutex_unlock(&esram_test_mutex);
-		return -EINVAL;
-	}
-
-	esram_test_dev.opened++;
-	mutex_unlock(&esram_test_dev.open_lock);
-	mutex_unlock(&esram_test_mutex);
-
-	return 0;
-}
-
-static int esram_test_release(struct inode *inode, struct file *file)
-{
-	mutex_lock(&esram_test_dev.open_lock);
-	esram_test_dev.opened = 0;
-	mutex_unlock(&esram_test_dev.open_lock);
-
-	return 0;
-}
-
-static const struct file_operations esram_test_file_ops = {
-	.open = esram_test_open,
-	.release = esram_test_release,
-	.unlocked_ioctl = esram_test_ioctl,
-	.llseek = no_llseek,
-};
-
-
-/**
- * intel_qrk_esram_test_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- *
- * This driver manages eSRAM on a per-page basis. Therefore if we find block
- * mode is enabled, or any global, block-level or page-level locks are in place
- * at module initialisation time - we bail out.
- */
-static int intel_qrk_esram_test_probe(struct platform_device * pdev)
-{
-	int retval = 0;
-	unsigned int minor = 0;
-	unsigned long order = 0;
-
-	esram_test_dev.size = INTEL_QRK_ESRAM_PAGE_COUNT * INTEL_QRK_ESRAM_PAGE_SIZE;
-
-	/* Allocate a page-aligned buffer matching the eSRAM capacity. */
-	for (order = 0; BIT(order) < INTEL_QRK_ESRAM_PAGE_COUNT; order ++);
-	if (order > MAX_ORDER) {
-		pr_err("%s: eSRAM page count %u exceeds MAX_ORDER %d\n",
-			__func__, INTEL_QRK_ESRAM_PAGE_COUNT, MAX_ORDER);
-		return -ENOMEM;
-	}
-	esram_test_dev.pdata = (char *)__get_free_pages(GFP_KERNEL, order);
-	if(unlikely(esram_test_dev.pdata == NULL)){
-		pr_err("Can't allocate %d bytes\n", esram_test_dev.size);
-		return -ENOMEM;
-	}
-
-	mutex_init(&esram_test_dev.open_lock);
-	cdev_init(&esram_test_dev.cdev, &esram_test_file_ops);
-	esram_test_dev.cdev.owner = THIS_MODULE;
-
-	retval = cdev_add(&esram_test_dev.cdev, MKDEV(esram_test_major, minor), 1);
-	if (retval) {
-		printk(KERN_ERR "chardev registration failed\n");
-		kfree(esram_test_dev.pdata);
-		return -EINVAL;
-	}
-	if (IS_ERR(device_create(esram_test_class, NULL,
-				 MKDEV(esram_test_major, minor), NULL,
-				 "esramtest%u", minor))){
-		dev_err(&pdev->dev, "can't create device\n");
-		kfree(esram_test_dev.pdata);
-		return -EINVAL;
-	}
-	printk(KERN_INFO "%s complete OK !!\n", __FUNCTION__);
-	return 0;
-
-}
-
-/**
- * intel_qrk_esram_remove
- *
- * @return 0 success < 0 failure
- *
- * Removes a platform device
- */
-static int intel_qrk_esram_test_remove(struct platform_device * pdev)
-{
-	unsigned int minor = MINOR(esram_test_dev.cdev.dev);
-
-	device_destroy(esram_test_class, MKDEV(esram_test_major, minor));
-	cdev_del(&esram_test_dev.cdev);
-	kfree(esram_test_dev.pdata);
-
-	return 0;
-}
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_qrk_esram_test_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	},
-	.remove = intel_qrk_esram_test_remove,
-};
-
-/**
- * intel_qrk_esram_init
- *
- * @return 0 success < 0 failure
- *
- * Module entry point
- */
-static int __init intel_qrk_esram_test_init(void)
-{
-	int retval = 0;
-	dev_t dev;
-
-	esram_test_class = class_create(THIS_MODULE,"qrk_esram_test");
-	if (IS_ERR(esram_test_class)) {
-		retval = PTR_ERR(esram_test_class);
-		printk(KERN_ERR "esram_test: can't register earam_test class\n");
-		goto err;
-	}
-
-	retval = alloc_chrdev_region(&dev, 0, 1, "esram_test");
-	if (retval) {
-		printk(KERN_ERR "earam_test: can't register character device\n");
-		goto err_class;
-	}
-	esram_test_major = MAJOR(dev);
-
-	memset(&esram_test_dev, 0x00, sizeof(esram_test_dev));
-	esram_test_dev.pldev = platform_create_bundle(
-		&intel_qrk_esram_test_driver, intel_qrk_esram_test_probe, NULL, 0, NULL, 0);
-
-	if(IS_ERR(esram_test_dev.pldev)){
-		printk(KERN_ERR "platform_create_bundle fail!\n"); 
-		retval = PTR_ERR(esram_test_dev.pldev);
-		goto err_class;
-	}
-
-	return 0;
-
-err_class:
-	class_destroy(esram_test_class);
-err:
-	return retval;
-}
-
-/**
- * intel_qrk_esram_exit
- *
- * Module exit
- */
-static void __exit intel_qrk_esram_test_exit(void)
-{
-	platform_device_unregister(esram_test_dev.pldev);
-	platform_driver_unregister(&intel_qrk_esram_test_driver);
-}
-
-MODULE_AUTHOR("Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Quark eSRAM ITS driver");
-MODULE_LICENSE("Dual BSD/GPL");
-
-module_init(intel_qrk_esram_test_init);
-module_exit(intel_qrk_esram_test_exit);
diff --git a/arch/x86/platform/intel-quark/intel_qrk_esram_test.h b/arch/x86/platform/intel-quark/intel_qrk_esram_test.h
deleted file mode 100644
index 8ebed69..0000000
--- a/arch/x86/platform/intel-quark/intel_qrk_esram_test.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright(c) 2013,2014 Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-/**
- * intel_qrk_esram_test.h
- *
- * Define integers for ioctl operation
- *
- * Author : Bryan O'Donoghue <bryan.odonoghue@linux.intel.com>
- */
-
-#ifndef __INTEL_QRK_ESRAM_TEST_H__
-#define __INTEL_QRK_ESRAM_TEST_H__
-
-#define QRK_ESRAM_IOCTL_BASE	255
-#define QRK_F_SW_APP_ESRAM_0	0x00000000
-#define QRK_F_SW_APP_ESRAM_1	0x00000001
-#define QRK_F_SW_APP_ESRAM_2	0x00000002
-#define QRK_F_SW_APP_ESRAM_3	0x00000003
-#define QRK_F_SW_APP_ESRAM_4	0x00000004
-#define QRK_F_SW_APP_ESRAM_5	0x00000005
-#define QRK_F_SW_APP_ESRAM_6	0x00000006
-#define QRK_F_SW_APP_ESRAM_7	0x00000007
-#define QRK_F_SW_APP_ESRAM_8	0x00000008
-
-#endif /* __INTEL_QRK_ESRAM_TEST_H__ */
-
diff --git a/arch/x86/platform/intel-quark/intel_qrk_imr_test.c b/arch/x86/platform/intel-quark/intel_qrk_imr_test.c
deleted file mode 100644
index 0f8cc32..0000000
--- a/arch/x86/platform/intel-quark/intel_qrk_imr_test.c
+++ /dev/null
@@ -1,351 +0,0 @@
-/*
- * Copyright(c) 2013 Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details
- */
-/*
- * Intel Quark IMR Test module
- *
- */
-
-#include <linux/cdev.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <asm/imr.h>
-#include <asm/iosf_mbi.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/printk.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/mm.h>
-#include <linux/module.h>
-#include <linux/types.h>
-
-
-#define DRIVER_NAME			"intel_qrk_imr_test"
-
-
-/* Memory-mapped SPI Flash address */
-#define ILB_SPIFLASH_BASEADDR			0xFF800000
-/* PUnit DMA block transfer size, in bytes */
-#define SPI_DMA_BLOCK_SIZE			512
-
-/**************************** Exported to LISA *******************************/
-
-/*
- * Internally-used ioctl code. At the moment it is not reserved by any mainline
- * driver.
- */
-#define IMR_TEST_IOCTL_CODE			0xE1
-
-/*
- * Integers for ioctl operation.
- */
-#define IOCTL_QRK_SANITY_CHECK_PUNIT_DMA	_IO(IMR_TEST_IOCTL_CODE, 0x00)
-#define IOCTL_QRK_IMR_1				_IO(IMR_TEST_IOCTL_CODE, 0x01)
-
-/*****************************************************************************/
-
-/**
- * struct intel_qrk_imr_dev
- *
- * Structure to represent module state/data/etc
- */
-struct intel_qrk_imr_test_dev {
-	unsigned int opened;
-	struct platform_device *pldev;	/* Platform device */
-	struct cdev cdev;
-	struct mutex open_lock;
-};
-
-static struct intel_qrk_imr_test_dev imr_test_dev;
-static struct class *imr_test_class;
-static DEFINE_MUTEX(imr_test_mutex);
-static int imr_test_major;
-
-/* PUnit DMA registers over side-band */
-#define PUNIT_SPI_DMA_COUNT_REG		0x60
-#define PUNIT_SPI_DMA_DEST_REG		0x61
-#define PUNIT_SPI_DMA_SRC_REG		0x62
-
-/**
- * ilb_spi_dma_read
- *
- * @param src: physical address in Legacy SPI Flash
- * @param dst: physical address of destination
- * @param dma_block_count: number of 512B SPI Flash blocks to be transferred
- *
- * Read-access iLB SPI via PUnit DMA engine.
- *
- */
-static void ilb_spi_dma_read(u32 *src, u32 *dst, u32 dma_block_count)
-{
-	pr_info("%s: src=%p, dst=%p, count=%u\n", __func__, src, dst,
-		dma_block_count);
-
-	/* Setup source and destination addresses. */
-	iosf_mbi_write(QRK_MBI_UNIT_RMU, QRK_MBI_RMU_WRITE,
-		PUNIT_SPI_DMA_SRC_REG, (u32) src);
-	iosf_mbi_write(QRK_MBI_UNIT_RMU, QRK_MBI_RMU_WRITE,
-		PUNIT_SPI_DMA_DEST_REG, (u32) dst);
-
-	pr_info("%s: starting transaction\n", __func__);
-
-	/*
-	 * Setup the number of block to be copied over. Transaction will start
-	 * as soon as the register is filled with value.
-	 */
-	iosf_mbi_write(QRK_MBI_UNIT_RMU, QRK_MBI_RMU_WRITE,
-		PUNIT_SPI_DMA_COUNT_REG, dma_block_count);
-
-	/* Poll for completion. */
-	while (dma_block_count > 0) {
-		iosf_mbi_read(QRK_MBI_UNIT_RMU,QRK_MBI_RMU_READ,
-			PUNIT_SPI_DMA_COUNT_REG, &dma_block_count);
-	}
-
-	pr_info("%s: transaction completed\n", __func__);
-}
-
-/**
- * punit_dma_sanity_check
- *
- * @return 0 if success, 1 if failure
- *
- * Perform a basic sanity check for PUnit DMA engine. Copy over a 512B SPI
- * Flash block.
- */
-static int punit_dma_sanity_check(void)
-{
-	int err = 0;
-	u32 *buffer = NULL;
-	u32 buf_ph_addr = 0;
-
-	/* Allocate 512B buffer for 1 SPI Flash block */
-	buffer = kzalloc(SPI_DMA_BLOCK_SIZE, GFP_KERNEL);
-        if (!buffer) {
-		err = -ENOMEM;
-		goto end;
-	}
-
-	/* DMA first SPI Flash block into buffer */
-	buf_ph_addr = (u32)virt_to_phys(buffer);
-	ilb_spi_dma_read((u32 *)ILB_SPIFLASH_BASEADDR, (u32 *)buf_ph_addr, 1);
-
-	kfree(buffer);
-end:
-	return err;
-}
-
-/**
- * imr_violate_kernel_punit_dma
- *
- * @return always 0
- *
- * PUnit-DMA access to the Uncompressed Kernel IMR.
- * This is based on set_imr_kernel_data() in intel_qrk_imr.c. Find the physical
- * address of .text section and copy a 512B chunk of legacy SPI via PuUnit DMA.
- *
- */
-static int imr_violate_kernel_punit_dma(void)
-{
-	extern unsigned long _text;
-	u32 kernel_text = (u32)virt_to_phys(&_text);
-
-	/* We expect this to trigger an IMR violation reset */
-	ilb_spi_dma_read((u32 *)ILB_SPIFLASH_BASEADDR, (u32 *)kernel_text, 1);
-
-	/*
-	 * If we're still alive, we have a serious bug:
-	 * - we didn't appropriately target the IMR?
-	 * - if we have, weren't we prevented from accessing?
-	 * - if we weren't prevented, it's unlikely we're alive with a dirty
-	 *   text section
-	 */
-	pr_err("%s: BUG: still running after DMAing into kernel text!?\n",
-		__func__);
-
-	return 0;
-}
-
-/*
- * File ops
- */
-static long imr_test_ioctl(struct file *file, unsigned int cmd,
-		unsigned long arg)
-{
-	int ret = -EINVAL;
-
-	switch (cmd) {
-		case IOCTL_QRK_SANITY_CHECK_PUNIT_DMA:
-			/* Check PUnit DMA actually works */
-			ret = punit_dma_sanity_check();
-			break;
-		case IOCTL_QRK_IMR_1:
-			/* Kernel IMR violation: PUnit DMA access */
-			ret = imr_violate_kernel_punit_dma();
-			break;
-		default:
-			break;
-	}
-
-	return ret;
-}
-
-static int imr_test_open(struct inode *inode, struct file *file)
-{
-	mutex_lock(&imr_test_mutex);
-	nonseekable_open(inode, file);
-
-	if (mutex_lock_interruptible(&imr_test_dev.open_lock)) {
-		mutex_unlock(&imr_test_mutex);
-		return -ERESTARTSYS;
-	}
-
-	if (imr_test_dev.opened) {
-		mutex_unlock(&imr_test_dev.open_lock);
-		mutex_unlock(&imr_test_mutex);
-		return -EINVAL;
-	}
-
-	imr_test_dev.opened++;
-	mutex_unlock(&imr_test_dev.open_lock);
-	mutex_unlock(&imr_test_mutex);
-	return 0;
-}
-
-static int imr_test_release(struct inode *inode, struct file *file)
-{
-	mutex_lock(&imr_test_dev.open_lock);
-	imr_test_dev.opened = 0;
-	mutex_unlock(&imr_test_dev.open_lock);
-
-	return 0;
-}
-
-static const struct file_operations imr_test_file_ops = {
-	.open = imr_test_open,
-	.release = imr_test_release,
-	.unlocked_ioctl = imr_test_ioctl,
-	.llseek = no_llseek,
-};
-
-/**
- * intel_qrk_imr_test_probe
- *
- * @param pdev: Platform device
- * @return 0 success < 0 failure
- *
- * Callback from platform sub-system to probe
- */
-static int intel_qrk_imr_test_probe(struct platform_device * pdev)
-{
-	int retval = 0;
-	unsigned int minor = 0;
-
-	mutex_init(&imr_test_dev.open_lock);
-	cdev_init(&imr_test_dev.cdev, &imr_test_file_ops);
-	imr_test_dev.cdev.owner = THIS_MODULE;
-
-	retval = cdev_add(&imr_test_dev.cdev, MKDEV(imr_test_major, minor), 1);
-	if (retval) {
-		printk(KERN_ERR "chardev registration failed\n");
-		return -EINVAL;
-	}
-	if (IS_ERR(device_create(imr_test_class, NULL,
-				 MKDEV(imr_test_major, minor), NULL,
-				 "imrtest%u", minor))){
-		dev_err(&pdev->dev, "can't create device\n");
-		return -EINVAL;
-	}
-
-	return 0;
-
-}
-
-static int intel_qrk_imr_test_remove(struct platform_device * pdev)
-{
-	unsigned int minor = MINOR(imr_test_dev.cdev.dev);
-
-	device_destroy(imr_test_class, MKDEV(imr_test_major, minor));
-	cdev_del(&imr_test_dev.cdev);
-
-	class_destroy(imr_test_class);
-
-	return 0;
-}
-
-/*
- * Platform structures useful for interface to PM subsystem
- */
-static struct platform_driver intel_qrk_imr_test_driver = {
-	.driver = {
-		.name = DRIVER_NAME,
-		.owner = THIS_MODULE,
-	},
-	.remove = intel_qrk_imr_test_remove,
-};
-
-/**
- * intel_qrk_imr_test_init
- *
- * Load module.
- */
-static int __init intel_qrk_imr_test_init(void)
-{
-	int retval = 0;
-	dev_t dev;
-
-	imr_test_class = class_create(THIS_MODULE,"qrk_imr_test");
-	if (IS_ERR(imr_test_class)) {
-		retval = PTR_ERR(imr_test_class);
-		printk(KERN_ERR "imr_test: can't register imr_test class\n");
-		goto err;
-	}
-
-	retval = alloc_chrdev_region(&dev, 0, 1, "imr_test");
-	if (retval) {
-		printk(KERN_ERR "earam_test: can't register character device\n");
-		goto err_class;
-	}
-	imr_test_major = MAJOR(dev);
-
-	memset(&imr_test_dev, 0x00, sizeof(imr_test_dev));
-	imr_test_dev.pldev = platform_create_bundle(
-		&intel_qrk_imr_test_driver, intel_qrk_imr_test_probe, NULL, 0, NULL, 0);
-
-	if(IS_ERR(imr_test_dev.pldev)){
-		printk(KERN_ERR "platform_create_bundle fail!\n");
-		retval = PTR_ERR(imr_test_dev.pldev);
-		goto err_class;
-	}
-
-	return 0;
-
-err_class:
-	class_destroy(imr_test_class);
-err:
-	return retval;
-}
-
-static void __exit intel_qrk_imr_test_exit(void)
-{
-	platform_device_unregister(imr_test_dev.pldev);
-	platform_driver_unregister(&intel_qrk_imr_test_driver);
-}
-
-module_init(intel_qrk_imr_test_init);
-module_exit(intel_qrk_imr_test_exit);
-
-MODULE_AUTHOR("Josef Ahmad <josef.ahmad@intel.com>");
-MODULE_DESCRIPTION("Quark IMR test module");
-MODULE_LICENSE("Dual BSD/GPL");
-
-- 
1.8.2

